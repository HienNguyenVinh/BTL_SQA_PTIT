package test;

import Model.NhanVien;
import Model.SuKien;
import dao.NhanVienDAO;
import dao.SuKienDAO;
import database.JDBCUtil;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Calendar;
import org.junit.After;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;

public class SuKienDAOTest {
    private SuKienDAO suKienDAO;
    private Connection connection;

    private static final String EXISTING_ID_FOR_TEST = "SK001";
    private static final String NON_EXISTENT_ID = "SK999";
    private static final String EXISTING_NAME_FOR_TEST = "Black Friday";
    private static final String NON_EXISTENT_NAME = "Sự kiện không tồn tại";
    private static final Date DATE_WITHIN_EXISTING_EVENT = Date.valueOf("2021-11-11");
    private static final Date DATE_OUTSIDE_ANY_EVENT = Date.valueOf("2000-01-01");

    @Before
    public void setUp() throws SQLException {
        // Get a connection before each test
        connection = JDBCUtil.getConnection();
        assertNotNull("Database connection should not be null", connection);

        // Disable auto-commit for transaction control (rollback)
        connection.setAutoCommit(false);
        System.out.println("Database connection established and auto-commit disabled.");

        // Instantiate the DAO
        // Note: The provided getInstance() creates a new instance each time,
        // which isn't a typical singleton pattern, but we follow the code.
        suKienDAO = SuKienDAO.getInstance();
        assertNotNull("SuKienDAO instance should not be null", suKienDAO);
    }

    @After
    public void tearDown() throws SQLException {
        if (connection != null && !connection.isClosed()) {
            try {
                // Rollback any changes made during the test
                connection.rollback();
                System.out.println("Transaction rolled back.");
            } catch (SQLException e) {
                System.err.println("Error rolling back transaction: " + e.getMessage());
                // Log or handle rollback failure if necessary, but continue closing
            } finally {
                // Ensure the connection is closed even if rollback fails
                try {
                    connection.close();
                    System.out.println("Database connection closed.");
                } catch (SQLException e) {
                    System.err.println("Error closing connection: " + e.getMessage());
                }
            }
        } else {
            System.out.println("Connection was null or already closed.");
        }
    }

    // Helper to create dates
    private Date createSqlDate(int year, int month, int day) {
        Calendar cal = Calendar.getInstance();
        cal.set(year, month - 1, day, 0, 0, 0); // month is 0-based
        cal.set(Calendar.MILLISECOND, 0);
        return new Date(cal.getTimeInMillis());
    }

    @Test
    public void testGetInstance() {
        // Basic test to ensure getInstance returns an object
        SuKienDAO instance1 = SuKienDAO.getInstance();
        SuKienDAO instance2 = SuKienDAO.getInstance();
        assertNotNull(instance1);
        assertNotNull(instance2);
        // Based on the provided code, these will be different instances.
        // assertNotSame(instance1, instance2); // Uncomment if verifying non-singleton behavior
    }

    @Test
    public void testInsert_Success() {
        // Arrange
        Date startDate = createSqlDate(2025, 5, 1);
        Date endDate = createSqlDate(2025, 5, 31);
        SuKien newSuKien = new SuKien(null, "Test Event Insert", 0.15f, startDate, endDate); // ID likely generated by DB

        // Act
        int result = suKienDAO.insert(newSuKien);

        // Assert
        assertEquals("Insert should affect 1 row", 1, result);
        // Optional: Verify insertion by fetching data (requires knowing the generated ID or using other criteria)
        // For example, fetch by name and date:
        ArrayList<SuKien> insertedEvents = suKienDAO.getByTen("Test Event Insert");
        assertNotNull(insertedEvents);
        assertFalse(insertedEvents.isEmpty());
        boolean found = false;
        for(SuKien sk : insertedEvents) {
            // Compare non-ID fields as ID might be generated
            if (sk.getTenSuKien().equals("Test Event Insert") &&
                    sk.getGiamGia() == 0.15f &&
                    sk.getNgayBatDau().toString().equals(startDate.toString()) && // Compare string representation for simplicity
                    sk.getNgayKetThuc().toString().equals(endDate.toString())) {
                found = true;
                // We can potentially get the generated ID here if needed for other tests
                System.out.println("Inserted event found with generated ID: " + sk.getMaSuKien());
                break;
            }
        }
        assertTrue("Inserted event should be retrievable", found);
    }

    @Test
    public void testInsert_Fail_NullData() {
        Date startDate = createSqlDate(2025, 5, 1);
        Date endDate = createSqlDate(2025, 5, 31);
        SuKien newSuKien = new SuKien(null, null, 0.15f, startDate, endDate);

        int result = suKienDAO.insert(newSuKien);
        assertEquals("insert() should return 0 if required data is null (DB constraint)", 0, result);
        System.out.println("Insert Null Data Test Passed (returned 0).");
    }


    @Test
    public void testInsert_SQLException() {
        JDBCUtil.overridePassword = "sai_password";
        try {
            int result = suKienDAO.insert(new SuKien());
            assertNull("Khi gặp SQLException, insert() phải trả về null", result);
        } catch (Exception e) {
            fail("insert() không được ném exception ra ngoài. Lỗi: " + e.getMessage());
        } finally {
            JDBCUtil.overridePassword = null;
        }
    }

    @Test
    public void testUpdateSuccess() {

        Date startDate = createSqlDate(2025, 6, 1);
        Date endDate = createSqlDate(2025, 6, 15);
        SuKien skToInsert = new SuKien(null, "Event To Update", 0.10f, startDate, endDate);
        suKienDAO.insert(skToInsert);

        ArrayList<SuKien> insertedList = suKienDAO.getByTen("Event To Update");
        assertTrue("Should find the event just inserted for update", insertedList != null && !insertedList.isEmpty());
        String generatedId = insertedList.get(0).getMaSuKien(); // Get the ID
        assertNotNull("Generated ID should not be null", generatedId);

        Date newEndDate = createSqlDate(2025, 6, 20);
        SuKien skToUpdate = new SuKien(generatedId, "Updated Event Name", 0.20f, startDate, newEndDate);

        int result = suKienDAO.update(skToUpdate);

        assertEquals("Update should affect 1 row", 1, result);

        SuKien updatedSk = suKienDAO.getById(generatedId);
        assertNotNull("Updated event should be found by ID", updatedSk);
        assertEquals("Name should be updated", "Updated Event Name", updatedSk.getTenSuKien());
        assertEquals("Discount should be updated", 0.20f, updatedSk.getGiamGia(), 0.001);
        assertEquals("End date should be updated", newEndDate.toString(), updatedSk.getNgayKetThuc().toString());
    }

    @Test
    public void testUpdateNotFound() {
        Date startDate = createSqlDate(2025, 7, 1);
        Date endDate = createSqlDate(2025, 7, 31);
        SuKien skToUpdate = new SuKien(NON_EXISTENT_ID, "Event That Does Not Exist", 0.05f, startDate, endDate);

        int result = suKienDAO.update(skToUpdate);

        assertEquals("Update should affect 0 rows if ID not found", 0, result);
    }

    @Test
    public void testUpdate_SQLException() {
        JDBCUtil.overridePassword = "sai_password";
        try {
            int result = suKienDAO.update(new SuKien());
            assertNull("Khi gặp SQLException, update() phải trả về null", result);
        } catch (Exception e) {
            fail("update() không được ném exception ra ngoài. Lỗi: " + e.getMessage());
        } finally {
            JDBCUtil.overridePassword = null;
        }
    }

    @Test
    public void testDeleteSuccess() {
        Date startDate = createSqlDate(2025, 8, 1);
        Date endDate = createSqlDate(2025, 8, 10);
        SuKien skToDelete = new SuKien(null, "Event To Delete", 0.05f, startDate, endDate);
        suKienDAO.insert(skToDelete);

        ArrayList<SuKien> insertedList = suKienDAO.getByTen("Event To Delete");
        assertTrue("Should find the event just inserted for deletion", insertedList != null && !insertedList.isEmpty());
        String generatedId = insertedList.get(0).getMaSuKien();
        assertNotNull("Generated ID for deletion should not be null", generatedId);

        int result = suKienDAO.delete(generatedId);

        assertEquals("Delete should affect 1 row", 1, result);

        SuKien deletedSk = suKienDAO.getById(generatedId);
        assertNull("Deleted event should not be found", deletedSk);
    }

    @Test
    public void testDeleteNotFound() {
        int result = suKienDAO.delete(NON_EXISTENT_ID);

        assertEquals("Delete should affect 0 rows if ID not found", 0, result);
    }

    @Test
    public void testDelete_SQLException() {
        JDBCUtil.overridePassword = "sai_password";
        try {
            int result = suKienDAO.delete("SK01");
            assertNull("Khi gặp SQLException, delete() phải trả về null", result);
        } catch (Exception e) {
            fail("delete() không được ném exception ra ngoài. Lỗi: " + e.getMessage());
        } finally {
            JDBCUtil.overridePassword = null;
        }
    }

    @Test
    public void testGetAll_Success() {
        ArrayList<SuKien> allSuKien = suKienDAO.getAll();

        assertNotNull("Result list should not be null", allSuKien);
        assertFalse("Result list should not be empty (assuming data exists)", allSuKien.isEmpty());
        System.out.println("Found " + allSuKien.size() + " events in getAll.");
    }

    @Test
    public void testGetAll_Empty() throws SQLException {
        try (Connection conn = JDBCUtil.getConnection()) {
            conn.setAutoCommit(false);

            PreparedStatement pstmt = conn.prepareStatement("DELETE FROM SUKIEN");

            int rowsDeleted = pstmt.executeUpdate();
            ArrayList<SuKien> result = suKienDAO.getAll();
            assertNotNull("getAll() should return an empty list, not null, when no data", result);
            assertEquals("getAll() should return an empty list when no data", 0, result.size());
            System.out.println("testGetAll_Empty: Skipped (requires specific empty DB state)");

            conn.rollback();
            System.out.println("Cleared test data.");
        } catch (SQLException e) {
            System.err.println("Failed to clear test data: " + e.getMessage());
        }
    }

    @Test
    public void testGetAll_SQLException() {
        JDBCUtil.overridePassword = "sai_password";
        try {
            ArrayList<SuKien> result = suKienDAO.getAll();
            assertNull("Khi gặp SQLException, getAll() phải trả về null", result);
        } catch (Exception e) {
            fail("getAll() không được ném exception ra ngoài. Lỗi: " + e.getMessage());
        } finally {
            JDBCUtil.overridePassword = null;
        }
    }

    @Test
    public void testGetById_Found() {
        Date startDate = createSqlDate(2025, 9, 1);
        Date endDate = createSqlDate(2025, 9, 10);
        SuKien skToFind = new SuKien(null, "Event To Find By ID", 0.25f, startDate, endDate);
        suKienDAO.insert(skToFind);
        ArrayList<SuKien> insertedList = suKienDAO.getByTen("Event To Find By ID");
        assertTrue("Should find the event just inserted", insertedList != null && !insertedList.isEmpty());
        String generatedId = insertedList.get(0).getMaSuKien();
        assertNotNull("Generated ID for getById test should not be null", generatedId);

        SuKien foundSk = suKienDAO.getById(generatedId);

        assertNotNull("Should find SuKien by existing ID", foundSk);
        assertEquals("Found SuKien should have the correct ID", generatedId, foundSk.getMaSuKien());
        assertEquals("Found SuKien should have the correct name", "Event To Find By ID", foundSk.getTenSuKien());
    }

    @Test
    public void testGetById_NotFound() {
        SuKien foundSk = suKienDAO.getById(NON_EXISTENT_ID);

        assertNull("Should return null for non-existent ID", foundSk);
    }

    @Test
    public void testGetById_SQLException() {
        JDBCUtil.overridePassword = "sai_password";
        try {
            SuKien result = suKienDAO.getById("SK01");
            assertNull("Khi gặp SQLException, getById() phải trả về null", result);
        } catch (Exception e) {
            fail("getById() không được ném exception ra ngoài. Lỗi: " + e.getMessage());
        } finally {
            JDBCUtil.overridePassword = null;
        }
    }

    @Test
    public void testGetByMaSuKienFound() {
        Date startDate = createSqlDate(2025, 10, 1);
        Date endDate = createSqlDate(2025, 10, 10);
        SuKien skToFind = new SuKien(null, "Event To Find By MaSuKien", 0.30f, startDate, endDate);
        suKienDAO.insert(skToFind);
        ArrayList<SuKien> insertedList = suKienDAO.getByTen("Event To Find By MaSuKien");
        assertTrue("Should find the event just inserted", insertedList != null && !insertedList.isEmpty());
        String generatedId = insertedList.get(0).getMaSuKien();
        assertNotNull("Generated ID for getByMaSuKien test should not be null", generatedId);

        ArrayList<SuKien> foundList = suKienDAO.getByMaSuKien(generatedId);

        assertNotNull("Result list should not be null", foundList);
        assertEquals("Should find exactly one SuKien by unique ID", 1, foundList.size());
        assertEquals("Found SuKien should have the correct ID", generatedId, foundList.get(0).getMaSuKien());
        assertEquals("Found SuKien should have the correct name", "Event To Find By MaSuKien", foundList.get(0).getTenSuKien());
    }

    @Test
    public void testGetByMaSuKienNotFound() {
        ArrayList<SuKien> foundList = suKienDAO.getByMaSuKien(NON_EXISTENT_ID);

        assertNotNull("Result list should not be null", foundList);
        assertTrue("Should return an empty list for non-existent ID", foundList.isEmpty());
    }

    @Test
    public void testGetByMaSuKien_SQLException() {
        JDBCUtil.overridePassword = "sai_password";
        try {
            ArrayList<SuKien> result = suKienDAO.getByMaSuKien("SK01");
            assertNull("Khi gặp SQLException, getByMaSuKien() phải trả về null", result);
        } catch (Exception e) {
            fail("getByMaSuKien() không được ném exception ra ngoài. Lỗi: " + e.getMessage());
        } finally {
            JDBCUtil.overridePassword = null;
        }
    }

    @Test
    public void testGetByTenFound() {
        Date startDate = createSqlDate(2025, 11, 1);
        Date endDate = createSqlDate(2025, 11, 10);
        String specificName = "Unique Event Name For Search";
        SuKien skToFind = new SuKien(null, specificName, 0.35f, startDate, endDate);
        suKienDAO.insert(skToFind);

        ArrayList<SuKien> foundList = suKienDAO.getByTen(specificName);

        assertNotNull("Result list should not be null", foundList);
        assertFalse("Should find at least one event by existing name", foundList.isEmpty());
        for(SuKien sk : foundList) {
            assertEquals("Found event should have the searched name", specificName, sk.getTenSuKien());
        }
    }

    @Test
    public void testGetByTenNotFound() {
        ArrayList<SuKien> foundList = suKienDAO.getByTen(NON_EXISTENT_NAME);

        assertNotNull("Result list should not be null", foundList);
        assertTrue("Should return an empty list for non-existent name", foundList.isEmpty());
    }

    @Test
    public void testGetByTen_SQLException() {
        JDBCUtil.overridePassword = "sai_password";
        try {
            ArrayList<SuKien> result = suKienDAO.getByTen("KM abc");
            assertNull("Khi gặp SQLException, getByTen() phải trả về null", result);
        } catch (Exception e) {
            fail("getByTen() không được ném exception ra ngoài. Lỗi: " + e.getMessage());
        } finally {
            JDBCUtil.overridePassword = null;
        }
    }

    @Test
    public void testGetByNgayFound() {
        Date startDate = createSqlDate(2025, 12, 10);
        Date endDate = createSqlDate(2025, 12, 20);
        Date dateToSearch = createSqlDate(2025, 12, 15);
        SuKien skInRange = new SuKien(null, "Event Covering Date", 0.40f, startDate, endDate);
        suKienDAO.insert(skInRange);

        ArrayList<SuKien> foundList = suKienDAO.getByNgay(dateToSearch);

        assertNotNull("Result list should not be null", foundList);
        assertFalse("Should find event(s) covering the specified date", foundList.isEmpty());
        boolean foundCorrectEvent = false;
        for (SuKien sk : foundList) {
            if (sk.getTenSuKien().equals("Event Covering Date")) {
                long searchTime = dateToSearch.getTime();
                if (searchTime >= sk.getNgayBatDau().getTime() && searchTime <= sk.getNgayKetThuc().getTime()) {
                    foundCorrectEvent = true;
                    break;
                }
            }
        }
        assertTrue("The specific inserted event should be found", foundCorrectEvent);
    }

    @Test
    public void testGetByNgayNotFound() {
        ArrayList<SuKien> foundList = suKienDAO.getByNgay(DATE_OUTSIDE_ANY_EVENT);

        assertNotNull("Result list should not be null", foundList);
        assertTrue("Should return an empty list for date outside any event", foundList.isEmpty());
    }


    @Test
    public void testGetByNgay_SQLException() {
        JDBCUtil.overridePassword = "sai_password";
        try {
            ArrayList<SuKien> result = suKienDAO.getByNgay(Date.valueOf("2021-12-24"));
            assertNull("Khi gặp SQLException, getNgayBatDau() phải trả về null", result);
        } catch (Exception e) {
            fail("getNgayBatDau() không được ném exception ra ngoài. Lỗi: " + e.getMessage());
        } finally {
            JDBCUtil.overridePassword = null;
        }
    }

    @Test
    public void testGetMaSuKienFound() {
        Date startDate = createSqlDate(2026, 1, 5);
        Date endDate = createSqlDate(2026, 1, 15);
        Date dateToSearch = createSqlDate(2026, 1, 10);
        SuKien skForMa = new SuKien(null, "Event For GetMaSuKien", 0.45f, startDate, endDate);
        suKienDAO.insert(skForMa);

        ArrayList<SuKien> insertedList = suKienDAO.getByTen("Event For GetMaSuKien");
        assertTrue("Should find the event just inserted", insertedList != null && !insertedList.isEmpty());
        String expectedId = insertedList.get(0).getMaSuKien();
        assertNotNull("Generated ID for getMaSuKien test should not be null", expectedId);

        String foundId = suKienDAO.getMaSuKien(dateToSearch);

        assertNotNull("Found ID should not be null", foundId);
        assertFalse("Found ID should not be empty", foundId.isEmpty());
        assertEquals("Found ID should match the expected ID", expectedId, foundId);
    }

    @Test
    public void testGetMaSuKienNotFound() {
        String foundId = suKienDAO.getMaSuKien(DATE_OUTSIDE_ANY_EVENT);

        assertNotNull("Result should not be null (DAO returns empty string)", foundId);
        assertEquals("Should return an empty string if no event found for the date", "", foundId);
    }

    @Test
    public void testGetMaSuKien_SQLException() {
        JDBCUtil.overridePassword = "sai_password";
        try {
            String result = suKienDAO.getMaSuKien(Date.valueOf("2222-12-2"));
            assertNull("Khi gặp SQLException, getNgayBatDau() phải trả về null", result);
        } catch (Exception e) {
            fail("getNgayBatDau() không được ném exception ra ngoài. Lỗi: " + e.getMessage());
        } finally {
            JDBCUtil.overridePassword = null;
        }
    }
}